---
title: promise
date: 2020-11-23 14:06:13
tags:
categories: 
- JS
- Promise

---

## Promise 学习

1. 对象的状态不受外界影响。**Promise对象代表一个异步操作**。有三种状态： **Pending（进行中），fulfilled（已成功）和rejected（已失败）**。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态
2. Promise 对象：三种状态，两种结果：
	1. pending -> resolved
	2. pending -> rejected

``` mermaid
graph LR
  A(pending) -->|resolve -> value| B(onFulfilled)
  A(pending) -->|reject -> error| C(onRejected)  

```

#### 1. Promise 原生应用

```javascript
const promise = new Promise((resolve, reject) => {
    resolve(100);
});
promise.then(res => {
    console.log(res);
}, err => {
    console.error(err);
}).catch(e => {
    console.log(e);
})
```

#### 2. Promise 的实现

``` javascript
class Promise {
    state = 'PENDING';
	value = undefined;
	reason = undefined;
	/*
	此处的executor是(resolve, reject) => {
        resolve(100);
    }
	*/ 
    constructor(executor) {
        const resolve = (value) => {
            if (this.state === 'PENDING') {
            	this.state = 'FULFILLED';
               	this.value = value;
            }
            
        }
        const reject = (reason) => {
            if (this.state === 'PENDING') {
                this.state = 'REJECTED';
                this.reason = reason;            	   
            }

        }
        
        executor(resolve, reject);
        
        /* executor(resolve, reject)执行完之后为
        ((value) => {
            if (this.state === 'PENDING') {
            	this.state = 'FULFILLED';
               	this.value = value;
            }
            
        }, (reason) => {
            if (this.state === 'PENDING') {
                this.state = 'REJECTED';
                this.reason = reason;            	   
            }

        }) => {
        	此处执行resolve方法/reject方法
            ((value) => {
                if (this.state === 'PENDING') {
                    this.state = 'FULFILLED';
                    this.value = value;
                }

            })(100);
        }
        */
    }

	/* then 之后运行结果为
	then(res => {console.log(res);}, err => {console.error(err);}) {
        if (this.state === 'FULFILLED') {
           （res => {console.log(res);}）(this.value);
        } else if (this.state === 'REJECTED') {
           （err => {console.error(err);}）(this.reason);        
        }
    }
	
	*/
	then(onFulfulled, onRejected) {
        if (this.state === 'FULFILLED') {
           onFulfulled(this.value);
        } else if (this.state === 'REJECTED') {
           onRejected(this.reason);        
        }
    }
}
const a = new Promise((resolve, reject) => {
    resolve(100);
});
a.then(res => {
    console.log(res);
}, err => {
    console.error(err);
})
```

#### 3. 改造Promise使得支持resolve 异步方法

> 上述的代码在执行 下面 语句会出错

``` javascript
var a = new Promise((reslove,reject) => {setTimeout(() => {resolve(1)},1000)});

a.then(res => console.log(res));

// 执行结果并不会等待1s后reslove(1);而是then之后直接打印了undefined
```

> 改造后代码如下，用发布订阅者模式

``` javascript
class Promise {
    state = 'PENDING';
	value = undefined;
	reason = undefined;
	onResolvedCallbacks = [];
	onRejectedCallbacks = [];
    constructor(executor) {
        const resolve = (value) => {
            if (this.state === 'PENDING') {
            	this.state = 'FULFILLED';
               	this.value = value;
                this.onResolvedCallbacks.forEach(fn => fn())
            }
        }
        const reject = (reason) => {
            if (this.state === 'PENDING') {
                this.state = 'REJECTED';
                this.reason = reason;    
                this.onRejectedCallbacks.forEach(fn => fn())
            }

        }
        executor(resolve, reject);
    }  

	then(onFulfilled, onRejected) {
        if (this.state === 'FULFILLED') {
           onFulfilled(this.value);
        } 
        if (this.state === 'REJECTED') {
           onRejected(this.reason);        
        }
        // 如果是还处于pending状态，onResolvedCallbacks和onRejectedCallbacks数组分别push成功onFulfilled的方法和失败onRejected的方法，在上面reslove/ewject方法里当触发resolve/reject 则将onResolvedCallbacks和onRejectedCallbacks 全部forEach循环调用所有存入的onFulfilled(this.value)方法和onRejected(this.reason)方法
        if (this.state === 'PENDING') {
            // 【这里push(() => {fn()}),是因为现在不想执行fn(), 等后面再forEach的时候再调用fn】！！！
           this.onResolvedCallbacks.push(() => {
               onFulfilled(this.value);
           });
            this.onRejectedCallbacks.push(() => {
                onRejected(this.reason);
            })
        }
    }
}
var a = new Promise((resolve,reject) => {setTimeout(() => {resolve(1)},1000)});

a.then(res => {
    console.log(res);
}, err => {
    console.error(err);
});
a.then(res => {
    console.log(res);
}, err => {
    console.error(err);
});
a.then(res => {
    console.log(res);
}, err => {
    console.error(err);
});
// 1
// 1
// 1
```

> 缺点：每次then之后不会返回Promise对象

#### 4. 改造Promise使得每次then都会返回一个Promise，即支持链式调用

``` javascript
class Promise {
    state = 'PENDING';
	value = undefined;
	reason = undefined;
	onResolvedCallbacks = [];
	onRejectedCallbacks = [];
    constructor(executor) {
        const resolve = (value) => {
            if (this.state === 'PENDING') {
            	this.state = 'FULFILLED';
               	this.value = value;
                this.onResolvedCallbacks.forEach(fn => fn());
            }
        }
        const reject = (reason) => {
            if (this.state === 'PENDING') {
                this.state = 'REJECTED';
                this.reason = reason;    
                this.onRejectedCallbacks.forEach(fn => fn());
            }
        }
        executor(resolve, reject);
    }  

	then(onFulfilled, onRejected) {
        if (this.state === 'FULFILLED') {
           return onFulfilled(this.value);
        } 
        if (this.state === 'REJECTED') {
           onRejected(this.reason);        
        }
        if (this.state === 'PENDING') {
           this.onResolvedCallbacks.push(() => {
               onFulfilled(this.value);
           });
            this.onRejectedCallbacks.push(() => {
                onRejected(this.reason);
            })
        }
    }
}
```

