---
title: CORS
date: 2020-11-23 10:09:06
tags: brower CORS
categories:
- brower 
- CORS
---

### 跨域

---

> ​	在**项目部署**的时候，如果把web服务/数据服务，部署到**同一台机器的同一个端口下，则属于`同源策略`，**（一般是这样 ），反之，如果**不在同一个服务器下/同一个端口下都属于非同源策略（`跨域请求`）**
>
> 如果`当前页面的url地址`和`请求数据的url地址`的 `协议，域名，端口`号**都一致**， 则为**同源策略**，否则**只要有一种不一致**，则为非同源，即**跨域**
>
> 真实项目中，跨域比较多见。原因：
>
> 1. 前后端分离
> 2. 为了保证服务器资源的合理利用，把服务器分成几类：
> 	1. WEB服务器（页面，css, js等资源）
> 	2. 图片服务器
> 	3. 音视频服务器
> 	4. 数据服务器
> 	5. 一个项目太大， 分散成很多子项目（基于二级域名部署，但是所有子项目之间的数据需要互相访问（内部联调）此时也已跨域为主）
> 	6. ajax 默认不允许跨域请求
>
> 
>
> **通过img的src，a link的herf 引入的资源和script，iframe是不存在跨域的。（图片，js脚本，视频）。只有ajax请求才会存在跨域**



----

开发环境下：

> 1. 前后端部署到同一个地址，如本地。(`tips: 前后端分离是指数据页面由谁渲染，如果是由前端ajax获取数据渲染页面是前后端分离，若由后端渲染页面是前后端不分离`)
> 2. 本地无需拿到后台代码，本地起一个web服务，通过修改本地的hosts文件，模拟出和数据服务器 的环境

非开发环境下：

> 	1. JSONP
>  	2. 其他一些方案：(IFRAME)
> 	 	1. window.name(处理主域相同，子域不同的相互请求)
> 	 	2. window.location.hash
> 	 	3. dockment.domian(处理主域相同，子域不同的相互请求)
> 	 	4. postMessage
>  	3. **CORS**(跨域资源共享)
>  	4. **webpack中的http proxy** (其实和nginx的反向代理是一样的)
>  	5. web socket

##### CORS

---

> 1. server端设置response 响应头
>
> **1）Access-Control-Allow-Origin**
>
> 该字段是必须的。它的值要么是请求时`Origin`字段的值，
>
> 1. **要么是一个`*`**，表示接受任意域名的请求。**（若为*号的时候 不能携带资源凭证。即Access-Control-Allow-Credentials设置为false!!!!）**
> 2. **要么是具体值”`http:xxx.x.x.x:port`“**，想要携带资源凭证，**只能指定一个源**,**不能指定多个**。
>
> **（2）Access-Control-Allow-Credentials**
>
> 该字段可选。它的值是一个**布尔值**，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为`true`，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为`true`，如果服务器不要浏览器发送Cookie，删除该字段即可。
>
> **（3）Access-Control-Expose-Headers**
>
> 该字段可选。CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。上面的例子指定，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值。
>
> 
>
> **post请求中，在真正的请求发送前，先发送一个option试探性请求，目的是验证当前请求能否和服务器建立连接。能连接上的话再发送真正的请求**

##### webpack 的http proxy

---

> ​       原理是**利用webpack-dev-server插件**，**构建本地服务AA**（预览本地开发的项目），前端发送的**请求先经过AA服务器，再由AA服务器发送到真正的服务器**。**AA起到中间代理**的作用。从而解决跨域问题。
>
> ​       **但是上述的操作是基于AA这个服务的（webpack-dev-server）**，最后部署的时候，并没有webpack-dev-server插件。此时需要基于其他的方案（例如nginx反向代理 ），实现出当初的AA服务代理的作用才可以！

##### nginx 跨域配置

---

``` nginx
# www.abcd.com -> www.bcd.com
# 设置bcd的nginx配置
server{
    listen 80；
    server_name www.bcd.com;
    location / {
        # 反向代理
        proxy_pass www.abcd.com;
        proxy_cookie_demo www.abcd.com www.bcd.com;
        add_header Access-Control-Origin www.abcd.com;
        add_header Access-Control-Allow-Credentials true;
    }
}
```



